<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master multi-objective optimization for quantitative trading. Learn Pareto optimality, weighted objectives, and multi-objective portfolio optimization.">
    <title>6.6 Multi-Objective Optimization | Quantitative Trading Mastery</title>

    <link rel="stylesheet" href="../../assets/css/shared-styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìà</text></svg>">

    <style>
        .key-concept { background: var(--bg-card); border-left: 4px solid var(--accent-cyan); padding: 1.5rem; border-radius: 0 var(--radius-md) var(--radius-md) 0; margin: 1.5rem 0; }
        .key-concept h3 { color: var(--accent-cyan); margin-bottom: 1rem; }
        .important-note { background: var(--warning-bg); border-left: 4px solid var(--warning); padding: 1.5rem; border-radius: 0 var(--radius-md) var(--radius-md) 0; margin: 1.5rem 0; }
        .important-note h3 { color: var(--warning); margin-bottom: 0.5rem; }
        .calculator-container { background: var(--bg-card); border-radius: var(--radius-lg); padding: 2rem; margin: 2rem 0; border: 1px solid rgba(255,255,255,0.1); }
        .calculator-container h3 { color: var(--accent-purple); margin-bottom: 1.5rem; }
        .input-group { margin-bottom: 1rem; }
        .input-group label { display: block; margin-bottom: 0.5rem; color: var(--text-secondary); }
        .input-group input, .input-group select { width: 100%; padding: 0.75rem; background: var(--bg-secondary); border: 1px solid rgba(255,255,255,0.1); border-radius: var(--radius-md); color: var(--text-primary); font-size: 1rem; }
        .input-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; }
        .calculate-btn { background: var(--gradient-secondary); color: white; border: none; padding: 1rem 2rem; border-radius: var(--radius-md); cursor: pointer; font-size: 1rem; font-weight: 600; width: 100%; margin-top: 1rem; transition: transform 0.2s, box-shadow 0.2s; }
        .calculate-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4); }
        .results-container { background: var(--bg-secondary); border-radius: var(--radius-md); padding: 1.5rem; margin-top: 1.5rem; }
        .result-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; }
        .result-item { text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: var(--radius-md); }
        .result-label { font-size: 0.85rem; color: var(--text-muted); display: block; margin-bottom: 0.5rem; }
        .result-value { font-size: 1.25rem; font-weight: 600; color: var(--text-primary); }
        .quiz-container { background: var(--bg-card); border-radius: var(--radius-lg); padding: 2rem; margin: 2rem 0; }
        .quiz-question { margin-bottom: 2rem; padding-bottom: 2rem; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .quiz-question:last-child { border-bottom: none; }
        .quiz-question h4 { color: var(--text-primary); margin-bottom: 1rem; }
        .quiz-options { display: flex; flex-direction: column; gap: 0.5rem; }
        .quiz-options button { background: var(--bg-secondary); border: 2px solid transparent; padding: 1rem; border-radius: var(--radius-md); color: var(--text-secondary); cursor: pointer; text-align: left; transition: all 0.2s; }
        .quiz-options button:hover:not(:disabled) { border-color: var(--accent-blue); background: var(--bg-tertiary); }
        .quiz-options button:disabled { cursor: not-allowed; opacity: 0.7; }
        .quiz-feedback { margin-top: 1rem; padding: 1rem; border-radius: var(--radius-md); display: none; }
        .quiz-feedback .correct { background: var(--success-bg); color: var(--success); }
        .quiz-feedback .incorrect { background: var(--error-bg); color: var(--error); }
        .score-container { text-align: center; padding: 2rem; background: var(--gradient-secondary); border-radius: var(--radius-lg); margin-top: 2rem; display: none; }
        .code-block { background: #1a1f2e; border-radius: var(--radius-lg); overflow: hidden; margin: 1.5rem 0; }
        .code-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; background: var(--bg-tertiary); border-bottom: 1px solid rgba(255,255,255,0.1); }
        .code-header span { color: var(--text-muted); font-size: 0.85rem; }
        .code-block pre { margin: 0; padding: 1.5rem; overflow-x: auto; }
        .code-block code { font-family: 'JetBrains Mono', 'Fira Code', monospace; font-size: 0.9rem; line-height: 1.6; }
        .chart-container { background: var(--bg-card); border-radius: var(--radius-lg); padding: 1.5rem; margin: 2rem 0; border: 1px solid rgba(255,255,255,0.1); position: relative; height: 400px; }
        .chart-container canvas { max-height: 350px; }
        .objective-cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin: 1.5rem 0; }
        .objective-card { background: var(--bg-secondary); padding: 1.5rem; border-radius: var(--radius-md); text-align: center; }
        .objective-card h4 { color: var(--accent-blue); margin-bottom: 0.5rem; }
        .slider-container { margin: 1.5rem 0; }
        .slider-container label { display: block; margin-bottom: 0.5rem; color: var(--text-secondary); }
        .slider-container input[type="range"] { width: 100%; }
        .slider-value { text-align: center; color: var(--accent-cyan); font-weight: 600; margin-top: 0.5rem; }
    </style>
</head>
<body>
    <nav class="module-nav-header">
        <div class="container">
            <div class="nav-content">
                <a href="../../index.html" class="nav-home">‚Üê Back to Course</a>
                <div class="nav-module-info">
                    <span class="nav-module-number">Module 6.6</span>
                    <span class="nav-module-title">Multi-Objective Optimization</span>
                </div>
                <a href="../module_7_risk_metrics/7.1_risk_framework.html" class="nav-next">Next Module ‚Üí</a>
            </div>
        </div>
    </nav>

    <header class="module-hero">
        <div class="container">
            <div class="module-hero-content">
                <div class="module-breadcrumb">
                    <span>Module 6: Optimization & Portfolio Theory</span>
                    <span class="breadcrumb-separator">‚Ä∫</span>
                    <span>6.6 Multi-Objective Optimization</span>
                </div>
                <h1>Multi-Objective Optimization</h1>
                <p class="module-subtitle">
                    Navigate the trade-offs between competing objectives in portfolio construction.
                    Master Pareto optimality, weighted objectives, and evolutionary algorithms.
                </p>
                <div class="module-meta">
                    <span class="meta-item">‚è±Ô∏è 45 min read</span>
                    <span class="meta-item">üìä 3 Visualizations</span>
                    <span class="meta-item">üíª Pareto Explorer</span>
                    <span class="meta-item">‚úÖ 5 Quiz Questions</span>
                </div>
            </div>
        </div>
    </header>

    <main class="container content-wrapper">
        <!-- Part 1: Why Should I Care? -->
        <section class="content-section fade-in">
            <h2>Part 1: Why Should I Care?</h2>

            <div class="important-note">
                <h3>Real-World Portfolios Have Multiple Goals</h3>
                <p>
                    In practice, investors rarely optimize for a single objective. They want high returns <em>and</em>
                    low risk <em>and</em> low drawdowns <em>and</em> high liquidity <em>and</em> low transaction costs.
                    Multi-objective optimization provides the framework to <strong>navigate these trade-offs systematically</strong>.
                </p>
            </div>

            <div class="key-concept">
                <h3>The Core Insight</h3>
                <p><strong>There is no single "best" portfolio when objectives conflict‚Äîonly a set of optimal trade-offs.</strong></p>
                <p style="margin-top: 1rem;">
                    The Pareto frontier represents all portfolios where you cannot improve one objective without
                    sacrificing another. Understanding this frontier gives you the power to choose the right
                    trade-off for your specific needs.
                </p>
            </div>

            <div class="objective-cards">
                <div class="objective-card">
                    <h4>Return</h4>
                    <p style="color: var(--text-muted);">Maximize expected gains</p>
                </div>
                <div class="objective-card">
                    <h4>Risk (Volatility)</h4>
                    <p style="color: var(--text-muted);">Minimize variance</p>
                </div>
                <div class="objective-card">
                    <h4>Drawdown</h4>
                    <p style="color: var(--text-muted);">Limit maximum loss</p>
                </div>
                <div class="objective-card">
                    <h4>Transaction Costs</h4>
                    <p style="color: var(--text-muted);">Minimize turnover</p>
                </div>
            </div>

            <div class="card-grid">
                <div class="card">
                    <h4 style="color: var(--accent-blue);">üéØ Explicit Trade-offs</h4>
                    <p>Instead of guessing, visualize exactly how much return you sacrifice for lower risk.</p>
                </div>
                <div class="card">
                    <h4 style="color: var(--accent-purple);">üìä Decision Support</h4>
                    <p>Present stakeholders with the Pareto frontier and let them choose based on preferences.</p>
                </div>
                <div class="card">
                    <h4 style="color: var(--accent-cyan);">üîß Flexible Objectives</h4>
                    <p>Add constraints like ESG scores, sector limits, or liquidity requirements as additional objectives.</p>
                </div>
            </div>
        </section>

        <!-- Part 2: Pareto Optimality -->
        <section class="content-section fade-in">
            <h2>Part 2: Pareto Optimality</h2>

            <div class="key-concept">
                <h3>Pareto Dominance</h3>
                <p>
                    Solution A <strong>dominates</strong> solution B if A is at least as good as B in all objectives,
                    and strictly better in at least one. A solution is <strong>Pareto optimal</strong> (non-dominated)
                    if no other solution dominates it.
                </p>
            </div>

            <div class="info-box info-box-info">
                <div class="info-box-title">Example: Two Portfolios</div>
                <table class="data-table">
                    <thead>
                        <tr><th>Portfolio</th><th>Return</th><th>Volatility</th><th>Max Drawdown</th><th>Dominated?</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>A</td><td>12%</td><td>15%</td><td>20%</td><td>No (Pareto optimal)</td></tr>
                        <tr><td>B</td><td>10%</td><td>18%</td><td>25%</td><td>Yes (by A)</td></tr>
                        <tr><td>C</td><td>8%</td><td>10%</td><td>12%</td><td>No (Pareto optimal)</td></tr>
                    </tbody>
                </table>
                <p style="margin-top: 1rem; color: var(--text-muted);">
                    Portfolio B is dominated by A (worse in all objectives). A and C are both Pareto optimal‚Äîchoosing
                    between them depends on your risk preferences.
                </p>
            </div>

            <div class="chart-container">
                <h4 style="margin-bottom: 1rem;">Pareto Frontier: Return vs. Risk</h4>
                <canvas id="paretoChart" height="350"></canvas>
            </div>

            <div class="key-concept">
                <h3>The Pareto Frontier</h3>
                <p>
                    The set of all Pareto optimal solutions forms the <strong>Pareto frontier</strong> (or Pareto front).
                    In portfolio optimization, this is analogous to the efficient frontier, but can extend to
                    more than two objectives.
                </p>
                <ul style="margin-top: 1rem; color: var(--text-secondary);">
                    <li>Solutions on the frontier represent optimal trade-offs</li>
                    <li>Moving along the frontier improves one objective at the cost of another</li>
                    <li>Solutions below/inside the frontier are suboptimal (dominated)</li>
                </ul>
            </div>
        </section>

        <!-- Part 3: Solution Methods -->
        <section class="content-section fade-in">
            <h2>Part 3: Solution Methods</h2>

            <h3>1. Weighted Sum Method</h3>
            <div class="formula-box">
                <div class="formula" style="text-align: center; font-size: 1.2rem; padding: 1rem;">
                    minimize Œ£ w·µ¢ f·µ¢(x) where Œ£w·µ¢ = 1
                </div>
                <p style="text-align: center; color: var(--text-muted);">
                    Combine multiple objectives into a single scalar using weights
                </p>
            </div>
            <div class="info-box info-box-warning" style="margin: 1rem 0;">
                <div class="info-box-title">Limitation</div>
                <p>Weighted sum cannot find points on non-convex regions of the Pareto frontier.</p>
            </div>

            <h3>2. Œµ-Constraint Method</h3>
            <div class="formula-box">
                <div class="formula" style="text-align: center; font-size: 1.1rem; padding: 1rem;">
                    minimize f‚ÇÅ(x)<br>
                    subject to: f‚±º(x) ‚â§ Œµ‚±º for j = 2, ..., k
                </div>
                <p style="text-align: center; color: var(--text-muted);">
                    Optimize one objective while constraining others
                </p>
            </div>

            <h3>3. Goal Programming</h3>
            <div class="formula-box">
                <div class="formula" style="text-align: center; font-size: 1.1rem; padding: 1rem;">
                    minimize Œ£ |f·µ¢(x) - goal·µ¢|
                </div>
                <p style="text-align: center; color: var(--text-muted);">
                    Minimize deviations from target goals for each objective
                </p>
            </div>

            <h3>4. Evolutionary Algorithms (NSGA-II)</h3>
            <div class="key-concept">
                <h3>NSGA-II: Non-dominated Sorting Genetic Algorithm</h3>
                <p>
                    A popular evolutionary approach that maintains a population of solutions and uses:
                </p>
                <ul style="margin-top: 0.5rem; color: var(--text-secondary);">
                    <li><strong>Non-dominated sorting:</strong> Rank solutions by dominance</li>
                    <li><strong>Crowding distance:</strong> Maintain diversity along the Pareto front</li>
                    <li><strong>Genetic operators:</strong> Crossover and mutation to explore solution space</li>
                </ul>
            </div>

            <div class="chart-container">
                <h4 style="margin-bottom: 1rem;">Comparing Solution Methods</h4>
                <canvas id="methodsChart" height="300"></canvas>
            </div>
        </section>

        <!-- Part 4: Python Implementation -->
        <section class="content-section fade-in">
            <h2>Part 4: Python Implementation</h2>

            <div class="code-block">
                <div class="code-header">
                    <span>multi_objective_optimization.py</span>
                    <button onclick="copyCode(this)" style="background: var(--bg-secondary); border: 1px solid rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: var(--radius-sm); color: var(--text-secondary); cursor: pointer;">Copy</button>
                </div>
                <pre><code class="language-python">"""
Multi-Objective Portfolio Optimization
======================================
Optimize portfolios across multiple conflicting objectives.
"""

import numpy as np
from scipy.optimize import minimize
from typing import List, Tuple, Callable
import matplotlib.pyplot as plt


class MultiObjectiveOptimizer:
    """Multi-objective portfolio optimization."""

    def __init__(self, returns: np.ndarray, cov_matrix: np.ndarray,
                 additional_objectives: List[Callable] = None):
        """
        Initialize multi-objective optimizer.

        Parameters
        ----------
        returns : np.ndarray
            Expected returns for each asset
        cov_matrix : np.ndarray
            Covariance matrix
        additional_objectives : List[Callable]
            Additional objective functions f(weights) -> float
        """
        self.returns = np.array(returns)
        self.cov = np.array(cov_matrix)
        self.n_assets = len(returns)
        self.additional_objectives = additional_objectives or []

    def portfolio_return(self, weights: np.ndarray) -> float:
        """Calculate portfolio expected return (to maximize)."""
        return -np.dot(weights, self.returns)  # Negative for minimization

    def portfolio_volatility(self, weights: np.ndarray) -> float:
        """Calculate portfolio volatility (to minimize)."""
        return np.sqrt(np.dot(weights.T, np.dot(self.cov, weights)))

    def weighted_sum(self, weight_return: float = 0.5,
                    weight_risk: float = 0.5,
                    allow_short: bool = False) -> dict:
        """
        Weighted sum method for multi-objective optimization.

        Parameters
        ----------
        weight_return : float
            Weight for return objective (maximize)
        weight_risk : float
            Weight for risk objective (minimize)
        allow_short : bool
            Allow short selling

        Returns
        -------
        dict
            Optimization results
        """
        n = self.n_assets
        init_weights = np.ones(n) / n

        def objective(w):
            ret_obj = self.portfolio_return(w)  # Already negative
            risk_obj = self.portfolio_volatility(w)
            return weight_return * ret_obj + weight_risk * risk_obj

        constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}]
        bounds = None if allow_short else tuple((0, 1) for _ in range(n))

        result = minimize(objective, init_weights, method='SLSQP',
                         bounds=bounds, constraints=constraints)

        weights = result.x
        return {
            'weights': weights,
            'return': np.dot(weights, self.returns),
            'volatility': self.portfolio_volatility(weights),
            'weight_return': weight_return,
            'weight_risk': weight_risk
        }

    def epsilon_constraint(self, target_return: float = None,
                          max_volatility: float = None,
                          allow_short: bool = False) -> dict:
        """
        Epsilon-constraint method.

        Optimize return subject to volatility constraint, or
        minimize volatility subject to return constraint.

        Parameters
        ----------
        target_return : float
            Minimum required return (if optimizing risk)
        max_volatility : float
            Maximum allowed volatility (if optimizing return)
        allow_short : bool
            Allow short selling

        Returns
        -------
        dict
            Optimization results
        """
        n = self.n_assets
        init_weights = np.ones(n) / n

        constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}]
        bounds = None if allow_short else tuple((0, 1) for _ in range(n))

        if max_volatility is not None:
            # Maximize return subject to volatility constraint
            constraints.append({
                'type': 'ineq',
                'fun': lambda w: max_volatility - self.portfolio_volatility(w)
            })
            objective = self.portfolio_return
        else:
            # Minimize volatility subject to return constraint
            constraints.append({
                'type': 'ineq',
                'fun': lambda w: np.dot(w, self.returns) - target_return
            })
            objective = self.portfolio_volatility

        result = minimize(objective, init_weights, method='SLSQP',
                         bounds=bounds, constraints=constraints)

        weights = result.x
        return {
            'weights': weights,
            'return': np.dot(weights, self.returns),
            'volatility': self.portfolio_volatility(weights),
            'target_return': target_return,
            'max_volatility': max_volatility
        }

    def generate_pareto_frontier(self, n_points: int = 50,
                                allow_short: bool = False) -> Tuple[np.ndarray, np.ndarray, List]:
        """
        Generate Pareto frontier using weighted sum method.

        Parameters
        ----------
        n_points : int
            Number of points on the frontier
        allow_short : bool
            Allow short selling

        Returns
        -------
        Tuple
            returns, volatilities, weights for each point
        """
        returns_list = []
        vol_list = []
        weights_list = []

        # Vary weights from pure return to pure risk
        for w_ret in np.linspace(0.01, 0.99, n_points):
            w_risk = 1 - w_ret
            result = self.weighted_sum(w_ret, w_risk, allow_short)
            returns_list.append(result['return'])
            vol_list.append(result['volatility'])
            weights_list.append(result['weights'])

        return np.array(returns_list), np.array(vol_list), weights_list

    def goal_programming(self, return_goal: float, vol_goal: float,
                        return_priority: float = 1.0,
                        vol_priority: float = 1.0,
                        allow_short: bool = False) -> dict:
        """
        Goal programming approach.

        Minimize weighted deviation from goals.

        Parameters
        ----------
        return_goal : float
            Target return
        vol_goal : float
            Target volatility
        return_priority : float
            Priority weight for return goal
        vol_priority : float
            Priority weight for volatility goal
        allow_short : bool
            Allow short selling

        Returns
        -------
        dict
            Optimization results
        """
        n = self.n_assets
        init_weights = np.ones(n) / n

        def objective(w):
            ret_dev = abs(np.dot(w, self.returns) - return_goal)
            vol_dev = abs(self.portfolio_volatility(w) - vol_goal)
            return return_priority * ret_dev + vol_priority * vol_dev

        constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}]
        bounds = None if allow_short else tuple((0, 1) for _ in range(n))

        result = minimize(objective, init_weights, method='SLSQP',
                         bounds=bounds, constraints=constraints)

        weights = result.x
        achieved_return = np.dot(weights, self.returns)
        achieved_vol = self.portfolio_volatility(weights)

        return {
            'weights': weights,
            'return': achieved_return,
            'volatility': achieved_vol,
            'return_goal': return_goal,
            'vol_goal': vol_goal,
            'return_deviation': abs(achieved_return - return_goal),
            'vol_deviation': abs(achieved_vol - vol_goal)
        }


def is_dominated(point: np.ndarray, other_points: np.ndarray) -> bool:
    """
    Check if a point is dominated by any other point.

    For minimization problems: A dominates B if A <= B in all objectives
    and A < B in at least one.

    Parameters
    ----------
    point : np.ndarray
        Point to check (objectives to minimize)
    other_points : np.ndarray
        Array of other points

    Returns
    -------
    bool
        True if point is dominated
    """
    for other in other_points:
        if np.all(other <= point) and np.any(other < point):
            return True
    return False


def find_pareto_frontier(points: np.ndarray) -> np.ndarray:
    """
    Find non-dominated points (Pareto frontier).

    Parameters
    ----------
    points : np.ndarray
        Array of points (n_points, n_objectives)

    Returns
    -------
    np.ndarray
        Boolean mask of non-dominated points
    """
    n_points = len(points)
    is_pareto = np.ones(n_points, dtype=bool)

    for i in range(n_points):
        if is_pareto[i]:
            # Check if point i is dominated
            for j in range(n_points):
                if i != j and is_pareto[j]:
                    if np.all(points[j] <= points[i]) and np.any(points[j] < points[i]):
                        is_pareto[i] = False
                        break

    return is_pareto


# Example usage
if __name__ == "__main__":
    # 4-asset portfolio
    expected_returns = np.array([0.12, 0.10, 0.07, 0.04])
    cov_matrix = np.array([
        [0.040, 0.012, 0.006, 0.002],
        [0.012, 0.025, 0.008, 0.003],
        [0.006, 0.008, 0.016, 0.004],
        [0.002, 0.003, 0.004, 0.001]
    ])

    optimizer = MultiObjectiveOptimizer(expected_returns, cov_matrix)

    # Generate Pareto frontier
    returns, vols, weights = optimizer.generate_pareto_frontier(n_points=20)

    print("Pareto Frontier Points:")
    print("-" * 40)
    for i in range(0, len(returns), 5):
        print(f"Return: {returns[i]:.2%}, Volatility: {vols[i]:.2%}")
        print(f"  Weights: {[f'{w:.1%}' for w in weights[i]]}")

    # Goal programming example
    print("\nGoal Programming (Target: 8% return, 12% vol):")
    result = optimizer.goal_programming(return_goal=0.08, vol_goal=0.12)
    print(f"  Achieved Return: {result['return']:.2%}")
    print(f"  Achieved Volatility: {result['volatility']:.2%}")
    print(f"  Return Deviation: {result['return_deviation']:.2%}")
    print(f"  Vol Deviation: {result['vol_deviation']:.2%}")</code></pre>
            </div>
        </section>

        <!-- Part 5: Interactive Calculator -->
        <section class="content-section fade-in">
            <h2>Part 5: Pareto Trade-off Explorer</h2>

            <div class="calculator-container">
                <h3>Multi-Objective Portfolio Explorer</h3>
                <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                    Adjust the weights to explore different points on the Pareto frontier.
                </p>

                <div class="slider-container">
                    <label>Return vs. Risk Trade-off</label>
                    <input type="range" id="tradeoffSlider" min="0" max="100" value="50" oninput="updateTradeoff()">
                    <div class="slider-value">
                        <span id="returnWeight">50%</span> Return Focus | <span id="riskWeight">50%</span> Risk Focus
                    </div>
                </div>

                <div class="input-row" style="margin-top: 1.5rem;">
                    <div class="input-group">
                        <label>Asset 1 Return (%)</label>
                        <input type="number" id="ret1" value="12" step="0.1" onchange="updateTradeoff()">
                    </div>
                    <div class="input-group">
                        <label>Asset 1 Volatility (%)</label>
                        <input type="number" id="vol1" value="20" step="0.1" onchange="updateTradeoff()">
                    </div>
                </div>
                <div class="input-row">
                    <div class="input-group">
                        <label>Asset 2 Return (%)</label>
                        <input type="number" id="ret2" value="8" step="0.1" onchange="updateTradeoff()">
                    </div>
                    <div class="input-group">
                        <label>Asset 2 Volatility (%)</label>
                        <input type="number" id="vol2" value="12" step="0.1" onchange="updateTradeoff()">
                    </div>
                </div>
                <div class="input-row">
                    <div class="input-group">
                        <label>Correlation</label>
                        <input type="number" id="correlation" value="0.3" step="0.1" min="-1" max="1" onchange="updateTradeoff()">
                    </div>
                </div>

                <div class="results-container" id="resultsContainer">
                    <h4 style="margin-bottom: 1rem; color: var(--accent-cyan);">Optimal Portfolio at Current Trade-off</h4>
                    <div class="result-grid">
                        <div class="result-item">
                            <span class="result-label">Asset 1 Weight</span>
                            <span class="result-value" id="w1">-</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Asset 2 Weight</span>
                            <span class="result-value" id="w2">-</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Portfolio Return</span>
                            <span class="result-value" id="portReturn">-</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Portfolio Volatility</span>
                            <span class="result-value" id="portVol">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h4 style="margin-bottom: 1rem;">Current Position on Pareto Frontier</h4>
                <canvas id="interactiveChart" height="300"></canvas>
            </div>
        </section>

        <!-- Part 6: Key Takeaways -->
        <section class="content-section fade-in">
            <h2>Part 6: Key Takeaways</h2>

            <div class="card" style="padding: 2rem;">
                <div style="display: grid; gap: 1.5rem;">
                    <div style="display: flex; gap: 1rem; align-items: flex-start;">
                        <span style="background: var(--accent-blue); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0;">1</span>
                        <div>
                            <strong style="color: var(--text-primary);">No single optimal solution when objectives conflict</strong>
                            <p style="color: var(--text-secondary); margin: 0.5rem 0 0;">The Pareto frontier provides the set of all optimal trade-offs.</p>
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: flex-start;">
                        <span style="background: var(--accent-blue); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0;">2</span>
                        <div>
                            <strong style="color: var(--text-primary);">Weighted sum is simple but has limitations</strong>
                            <p style="color: var(--text-secondary); margin: 0.5rem 0 0;">Cannot find non-convex regions; use Œµ-constraint or evolutionary algorithms for complete frontiers.</p>
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: flex-start;">
                        <span style="background: var(--accent-blue); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0;">3</span>
                        <div>
                            <strong style="color: var(--text-primary);">Present the frontier, let stakeholders choose</strong>
                            <p style="color: var(--text-secondary); margin: 0.5rem 0 0;">Decision-makers can select their preferred trade-off based on risk tolerance and goals.</p>
                        </div>
                    </div>
                    <div style="display: flex; gap: 1rem; align-items: flex-start;">
                        <span style="background: var(--accent-blue); color: white; width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0;">4</span>
                        <div>
                            <strong style="color: var(--text-primary);">Extend beyond return and risk</strong>
                            <p style="color: var(--text-secondary); margin: 0.5rem 0 0;">Add objectives like drawdown, turnover, ESG scores, or liquidity constraints.</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part 7: Quiz -->
        <section class="content-section fade-in">
            <h2>Part 7: Knowledge Check</h2>

            <div class="quiz-container">
                <div class="quiz-question" id="q1">
                    <h4>1. What does it mean for solution A to "dominate" solution B?</h4>
                    <div class="quiz-options">
                        <button onclick="checkAnswer(1, 'a')">a) A has higher return only</button>
                        <button onclick="checkAnswer(1, 'b')">b) A is at least as good in all objectives and strictly better in at least one</button>
                        <button onclick="checkAnswer(1, 'c')">c) A has lower risk only</button>
                        <button onclick="checkAnswer(1, 'd')">d) A was found first</button>
                    </div>
                    <div class="quiz-feedback" id="feedback1"></div>
                </div>

                <div class="quiz-question" id="q2">
                    <h4>2. What is the Pareto frontier?</h4>
                    <div class="quiz-options">
                        <button onclick="checkAnswer(2, 'a')">a) The highest return portfolio</button>
                        <button onclick="checkAnswer(2, 'b')">b) The set of all non-dominated solutions</button>
                        <button onclick="checkAnswer(2, 'c')">c) The lowest risk portfolio</button>
                        <button onclick="checkAnswer(2, 'd')">d) A single optimal portfolio</button>
                    </div>
                    <div class="quiz-feedback" id="feedback2"></div>
                </div>

                <div class="quiz-question" id="q3">
                    <h4>3. What is a limitation of the weighted sum method?</h4>
                    <div class="quiz-options">
                        <button onclick="checkAnswer(3, 'a')">a) It's too slow to compute</button>
                        <button onclick="checkAnswer(3, 'b')">b) It cannot find non-convex regions of the Pareto frontier</button>
                        <button onclick="checkAnswer(3, 'c')">c) It only works with two objectives</button>
                        <button onclick="checkAnswer(3, 'd')">d) It requires machine learning</button>
                    </div>
                    <div class="quiz-feedback" id="feedback3"></div>
                </div>

                <div class="quiz-question" id="q4">
                    <h4>4. In the Œµ-constraint method, how are secondary objectives handled?</h4>
                    <div class="quiz-options">
                        <button onclick="checkAnswer(4, 'a')">a) They are ignored</button>
                        <button onclick="checkAnswer(4, 'b')">b) They become constraints with bounds</button>
                        <button onclick="checkAnswer(4, 'c')">c) They are combined into one objective</button>
                        <button onclick="checkAnswer(4, 'd')">d) They are solved sequentially</button>
                    </div>
                    <div class="quiz-feedback" id="feedback4"></div>
                </div>

                <div class="quiz-question" id="q5">
                    <h4>5. Why might you add transaction costs as an objective?</h4>
                    <div class="quiz-options">
                        <button onclick="checkAnswer(5, 'a')">a) To maximize trading frequency</button>
                        <button onclick="checkAnswer(5, 'b')">b) To limit portfolio turnover and implementation costs</button>
                        <button onclick="checkAnswer(5, 'c')">c) To increase broker commissions</button>
                        <button onclick="checkAnswer(5, 'd')">d) Transaction costs are irrelevant</button>
                    </div>
                    <div class="quiz-feedback" id="feedback5"></div>
                </div>

                <div class="score-container" id="scoreContainer">
                    <h3>Quiz Complete! Score: <span id="finalScore">0</span>/5</h3>
                </div>
            </div>
        </section>
    </main>

    <script>
        // Quiz
        const correctAnswers = { 1: 'b', 2: 'b', 3: 'b', 4: 'b', 5: 'b' };
        const explanations = {
            1: { 'a': 'Domination requires being at least as good in ALL objectives.', 'b': 'Correct! This is the formal definition of Pareto dominance.', 'c': 'Must consider all objectives, not just risk.', 'd': 'Order of discovery is irrelevant.' },
            2: { 'a': 'That\'s just one point, not a frontier.', 'b': 'Correct! The Pareto frontier is the set of all non-dominated solutions.', 'c': 'That\'s also just one point.', 'd': 'There\'s no single optimal when objectives conflict.' },
            3: { 'a': 'Weighted sum is actually very fast.', 'b': 'Correct! Weighted sum only finds convex portions of the frontier.', 'c': 'It works with any number of objectives.', 'd': 'No ML required for weighted sum.' },
            4: { 'a': 'Secondary objectives are explicitly handled.', 'b': 'Correct! They become inequality constraints with Œµ bounds.', 'c': 'That\'s the weighted sum approach.', 'd': 'They\'re handled simultaneously as constraints.' },
            5: { 'a': 'The goal is usually to minimize trading.', 'b': 'Correct! Adding turnover as an objective helps find stable, cost-efficient portfolios.', 'c': 'Lower costs are generally preferred.', 'd': 'Transaction costs significantly impact real returns.' }
        };
        let quizAnswers = {};

        function checkAnswer(q, a) {
            const feedback = document.getElementById(`feedback${q}`);
            const isCorrect = a === correctAnswers[q];
            quizAnswers[q] = a;
            feedback.innerHTML = `<div class="${isCorrect ? 'correct' : 'incorrect'}">${isCorrect ? '‚úì Correct!' : '‚úó Incorrect.'} ${explanations[q][a]}</div>`;
            feedback.style.display = 'block';
            document.querySelectorAll(`#q${q} button`).forEach(btn => btn.disabled = true);
            if (Object.keys(quizAnswers).length === 5) {
                const score = Object.keys(quizAnswers).reduce((sum, q) => sum + (quizAnswers[q] === correctAnswers[q] ? 1 : 0), 0);
                document.getElementById('finalScore').textContent = score;
                document.getElementById('scoreContainer').style.display = 'block';
            }
        }

        // Interactive Trade-off Calculator
        let interactiveChart = null;

        function updateTradeoff() {
            const sliderValue = parseFloat(document.getElementById('tradeoffSlider').value);
            const returnWeight = sliderValue / 100;
            const riskWeight = 1 - returnWeight;

            document.getElementById('returnWeight').textContent = Math.round(returnWeight * 100) + '%';
            document.getElementById('riskWeight').textContent = Math.round(riskWeight * 100) + '%';

            const ret1 = parseFloat(document.getElementById('ret1').value) / 100;
            const ret2 = parseFloat(document.getElementById('ret2').value) / 100;
            const vol1 = parseFloat(document.getElementById('vol1').value) / 100;
            const vol2 = parseFloat(document.getElementById('vol2').value) / 100;
            const corr = parseFloat(document.getElementById('correlation').value);

            // Simple two-asset optimization using weighted sum
            let bestW1 = 0.5;
            let bestScore = Infinity;

            for (let w1 = 0; w1 <= 1; w1 += 0.01) {
                const w2 = 1 - w1;
                const portRet = w1 * ret1 + w2 * ret2;
                const portVar = w1*w1*vol1*vol1 + w2*w2*vol2*vol2 + 2*w1*w2*vol1*vol2*corr;
                const portVol = Math.sqrt(portVar);

                // Weighted sum (minimize -return and volatility)
                const score = -returnWeight * portRet + riskWeight * portVol;
                if (score < bestScore) {
                    bestScore = score;
                    bestW1 = w1;
                }
            }

            const w2 = 1 - bestW1;
            const portRet = bestW1 * ret1 + w2 * ret2;
            const portVar = bestW1*bestW1*vol1*vol1 + w2*w2*vol2*vol2 + 2*bestW1*w2*vol1*vol2*corr;
            const portVol = Math.sqrt(portVar);

            document.getElementById('w1').textContent = (bestW1 * 100).toFixed(1) + '%';
            document.getElementById('w2').textContent = (w2 * 100).toFixed(1) + '%';
            document.getElementById('portReturn').textContent = (portRet * 100).toFixed(2) + '%';
            document.getElementById('portVol').textContent = (portVol * 100).toFixed(2) + '%';

            // Update interactive chart
            updateInteractiveChart(ret1, ret2, vol1, vol2, corr, portVol * 100, portRet * 100);
        }

        function updateInteractiveChart(ret1, ret2, vol1, vol2, corr, currentVol, currentRet) {
            const ctx = document.getElementById('interactiveChart').getContext('2d');

            // Generate Pareto frontier
            const frontierPoints = [];
            for (let w1 = 0; w1 <= 1; w1 += 0.02) {
                const w2 = 1 - w1;
                const portRet = (w1 * ret1 + w2 * ret2) * 100;
                const portVar = w1*w1*vol1*vol1 + w2*w2*vol2*vol2 + 2*w1*w2*vol1*vol2*corr;
                const portVol = Math.sqrt(portVar) * 100;
                frontierPoints.push({x: portVol, y: portRet});
            }

            if (interactiveChart) {
                interactiveChart.destroy();
            }

            interactiveChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Pareto Frontier',
                        data: frontierPoints,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        showLine: true,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0
                    }, {
                        label: 'Current Selection',
                        data: [{x: currentVol, y: currentRet}],
                        backgroundColor: '#ef4444',
                        pointRadius: 12,
                        pointStyle: 'star'
                    }, {
                        label: 'Individual Assets',
                        data: [{x: vol1 * 100, y: ret1 * 100}, {x: vol2 * 100, y: ret2 * 100}],
                        backgroundColor: ['#22c55e', '#f59e0b'],
                        pointRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: { legend: { labels: { color: '#94a3b8' } } },
                    scales: {
                        x: { min: 0, max: 30, title: { display: true, text: 'Volatility (%)', color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' } },
                        y: { min: 0, max: 20, title: { display: true, text: 'Expected Return (%)', color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' } }
                    }
                }
            });
        }

        // Static Charts
        function initCharts() {
            // Pareto Chart
            const ctx1 = document.getElementById('paretoChart').getContext('2d');

            // Generate sample portfolios
            const dominated = [];
            const paretoFront = [];

            for (let i = 0; i < 100; i++) {
                const vol = 5 + Math.random() * 20;
                const ret = 2 + vol * 0.4 + (Math.random() - 0.5) * 8;
                dominated.push({x: vol, y: ret});
            }

            // Pareto frontier
            for (let vol = 5; vol <= 25; vol += 0.5) {
                const ret = 4 + (vol - 5) * 0.5 - (vol - 15) ** 2 * 0.005;
                paretoFront.push({x: vol, y: ret});
            }

            new Chart(ctx1, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Dominated Portfolios',
                        data: dominated,
                        backgroundColor: 'rgba(148, 163, 184, 0.3)',
                        pointRadius: 4
                    }, {
                        label: 'Pareto Frontier',
                        data: paretoFront,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        showLine: true,
                        fill: false,
                        tension: 0.4,
                        pointRadius: 0,
                        borderWidth: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: { legend: { labels: { color: '#94a3b8' } } },
                    scales: {
                        x: { min: 0, max: 30, title: { display: true, text: 'Volatility (%)', color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' } },
                        y: { min: 0, max: 20, title: { display: true, text: 'Expected Return (%)', color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' } }
                    }
                }
            });

            // Methods Comparison Chart
            const ctx2 = document.getElementById('methodsChart').getContext('2d');
            new Chart(ctx2, {
                type: 'bar',
                data: {
                    labels: ['Weighted Sum', 'Œµ-Constraint', 'Goal Programming', 'NSGA-II'],
                    datasets: [{
                        label: 'Computational Cost',
                        data: [2, 3, 2, 8],
                        backgroundColor: 'rgba(59, 130, 246, 0.7)'
                    }, {
                        label: 'Coverage (Non-convex)',
                        data: [4, 8, 5, 10],
                        backgroundColor: 'rgba(34, 197, 94, 0.7)'
                    }, {
                        label: 'Ease of Implementation',
                        data: [9, 7, 8, 4],
                        backgroundColor: 'rgba(139, 92, 246, 0.7)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: { legend: { labels: { color: '#94a3b8' } } },
                    scales: {
                        x: { grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' } },
                        y: { title: { display: true, text: 'Score (1-10)', color: '#94a3b8' }, grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#64748b' }, max: 10 }
                    }
                }
            });
        }

        function copyCode(btn) {
            const code = btn.closest('.code-block').querySelector('code').textContent;
            navigator.clipboard.writeText(code);
            btn.textContent = 'Copied!';
            setTimeout(() => btn.textContent = 'Copy', 2000);
        }

        document.addEventListener('DOMContentLoaded', function() { initCharts(); updateTradeoff(); });
    </script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>